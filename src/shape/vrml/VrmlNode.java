package shape.vrml;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.StreamTokenizer;
import java.util.List;

import numeric.geom.dim3.Quaternion;
import numeric.geom.dim3.Vector3d;

/**
 * VrmlNodes know how to parse themselves from a StreamTokenizer positioned
 * over their name or opening curly brace.
 * 
 * They also know how to convert themselves to the equivalent PXN format and
 * write themselves to a text file.
 * 
 * @author nickrowell
 */
public class VrmlNode 
{
    // Used to assign names to nodes for e.g. DEF/USE tags or PXN file names.
    // Nodes that have a DEF tag are given names.
    String name;
    
    // Character used to indent lines in PXN file.
    public static String indentChar = " ";
    
    @Override
    public int hashCode() 
    {
        int hash = 7;
        hash = 89 * hash + (this.name != null ? this.name.hashCode() : 0);
        return hash;
    }
    
    @Override
    public boolean equals(Object obj)
    {
        if (obj == null)
            return false;
        if (obj == this)
            return true;
        if (!(obj instanceof VrmlNode))
            return false;

        VrmlNode that = (VrmlNode) obj;
        return this.name.equals(that.name);
    }
    
    public VrmlNode(String _name)
    {
        name = _name;
    }
    
    public String toString()
    {
        return "Node: "+name;
    }
    
    
    
    
    // A node is any VRML file construct that uses
    // curly braces to enclose it's components.
    static enum Type
    {
        // Top level grouping nodes
        Transform, 
        Group, 
        // Shape nodes
        Shape,
        Appearance,
        Material,
        IndexedFaceSet,
        Coordinate,
        Normal,
        Unknown;
    }
    
    static Type getNodeType(String title)
    {
        if(title.equalsIgnoreCase("Transform")) return Type.Transform;
        if(title.equalsIgnoreCase("Group")) return Type.Group;
        if(title.equalsIgnoreCase("Shape")) return Type.Shape;
        if(title.equalsIgnoreCase("Appearance")) return Type.Appearance;
        if(title.equalsIgnoreCase("Material")) return Type.Material;
        if(title.equalsIgnoreCase("IndexedFaceSet")) return Type.IndexedFaceSet;
        if(title.equalsIgnoreCase("Coordinate")) return Type.Coordinate;
        if(title.equalsIgnoreCase("Normal")) return Type.Normal;
        
        return Type.Unknown;
    }
        
    /**
     * Will need to adjust this method as different VRML sources are used.
     * @param name
     * @return 
     */
    static boolean nameIsAutoGenerated(String name)
    {
        // Include other conditions to identify auto-generated names
        if(name.startsWith("__")) return true;
        if(name.startsWith("NAUO_NAME")) return true;
        
        return false;
    }
    

    
    
    // Read a variety of node types. Check for DEF/USE tags.
    static VrmlNode parseNode(StreamTokenizer st, List<VrmlNode> DEFs) throws IOException
    {
        
        if(st.ttype == StreamTokenizer.TT_WORD)
        {
            // Look up previously defined Node
            if(st.sval.equals("USE"))
            {
                // Node references previously defined node
                st.nextToken();
                VrmlNode compare = new VrmlNode(st.sval);
                
                if(!DEFs.contains(compare))
                {
                    System.err.println("Compare node = "+compare.toString());
                    for(VrmlNode node : DEFs)
                        System.err.println(node.toString());
                    
                    throw new RuntimeException("USE target not found: "+compare.name);
                }
                st.nextToken();
                return DEFs.get(DEFs.indexOf(compare));
            }
            
            // We are either a defined or undefined node.
            String name = "";
            boolean DEF = false;
            
            // Detect defined nodes
            if(st.sval.equals("DEF"))
            {
                // Notify that we should place this node in the DEFs list for
                // future reference.
                DEF = true;
                // Move onto node name
                st.nextToken();
                name = st.sval;
                // Move onto node title
                st.nextToken();
            }
            
            VrmlNode.Type type = VrmlNode.getNodeType(st.sval);
            
            // Move on to opening curly brace
            st.nextToken();

            VrmlNode out;
            

            switch(type)
            {
                case Transform:      out = VrmlTransformNode.parse(st, name, DEFs); break;
                case Group:          out = VrmlGroupNode.parse(st, name, DEFs); break;
                case Shape:          out = VrmlShapeNode.parse(st, name, DEFs); break;
                case Appearance:     out = VrmlAppearanceNode.parse(st, name, DEFs); break;
                case Material:       out = VrmlMaterialNode.parse(st, name); break;    
                case IndexedFaceSet: out = VrmlIndexedFaceSetNode.parse(st, name, DEFs); break;
                case Coordinate:     out = VrmlCoordinateNode.parse(st, name, DEFs); break;    
                case Normal:         out = VrmlNormalNode.parse(st, name, DEFs); break;
                case Unknown:
                default: throw new RuntimeException("Encountered unknown node");
            }

            // Add defined nodes to DEFs list for future reference
            if(DEF) DEFs.add(out);
            
            return out;
            
        }
        else
        {
            throw new RuntimeException("First token of node is not a word: "
                                        +st.toString());
        }
        
    }
    
    
    
    // Some node parsing utility functions
    
    // streamtokenizer on opening square brace on entry
    // Points are triples separated by commas, and ending with ]
    static void parseTriples(StreamTokenizer st, List<Triple<Float>> points) throws IOException
    {
        // Move to start of first point, or closing ] for empty point field
        st.nextToken();
        
        while(!foundClosingSquareBrace(st))
        {
            points.add(parseTripleFloat(st));
        }
        // Position stream tokenizer just after closing square brace
        st.nextToken();
    }
    
    static Vector3d parseVector3d(StreamTokenizer st) throws IOException
    {
        Triple<Float> t = parseTripleFloat(st);
        return new Vector3d(t.x, t.y, t.z);
    }
    
    static Quaternion parseQuaternion(StreamTokenizer st) throws IOException
    {
        Quadruple t = parseQuadruple(st);
        
        // Assume we are dealing with a vrml SFRotation node.
        
        // Rotation axis defined by first three values
        Vector3d axis = new Vector3d(t.w, t.x, t.y);
        
        // Angle [radians] defined by fourth value
        double angle = t.z;
        
        return new Quaternion(axis, angle);
    }    
    
    // st must be aligned with first element of quadruple. Elements
    // form consecutive words in tokenized string.
    // On exit, st is aligned with first token after the quadruple.
    static Quadruple parseQuadruple(StreamTokenizer st) throws IOException
    {
        float w = parseFloat(st);
        float x = parseFloat(st);
        float y = parseFloat(st);
        float z = parseFloat(st);
        
        return new Quadruple(w,x,y,z);
    }
    
        
    // st must be aligned with first element of triple. Elements
    // form consecutive words in tokenized string
    static Triple<Integer> parseTripleInt(StreamTokenizer st) throws IOException
    {
        int x = parseInt(st);
        int y = parseInt(st);
        int z = parseInt(st);
        
        return new Triple<Integer>(x,y,z);
    }
    
    // st must be aligned with first element of triple. Elements
    // form consecutive words in tokenized string
    static Triple<Float> parseTripleFloat(StreamTokenizer st) throws IOException
    {
        float x = parseFloat(st);
        float y = parseFloat(st);
        float z = parseFloat(st);
        
        return new Triple<Float>(x,y,z);
    }
    
        
    /**
     * Reads the current token as a float and move on to next token.
     * 
     * StreamTokenizer can't parse numbers in exponential format (eg 1e6), so
     * we have to work around this here by peeking ahead to see if the next
     * token has the format eXXXX.
     */
    static float parseFloat(StreamTokenizer st) throws IOException
    {
        
        if(st.ttype != StreamTokenizer.TT_NUMBER) 
            throw new RuntimeException("Badly formed float at "+st.toString());
        double numb = st.nval;

        // Attempt to read exponent
        int next_token = st.nextToken();
        
        if (next_token == StreamTokenizer.TT_WORD )
        {
               char nextLetter = st.sval.charAt(0);
               if ( (nextLetter == 'e' ) || (nextLetter == 'E' ) )
               {
                       String exp = st.sval.substring(1);

                       numb *= Math.pow(10, Double.parseDouble(exp));
               }
               else
               {
                       st.pushBack();  // its not exponential notation
               }
        }
        else
        {
               st.pushBack();
        }
        
        st.nextToken();
        return (float)numb;
    }
    
    
    
    /**
     * Reads the current token as an int and move on to next token.
     * 
     */
    static int parseInt(StreamTokenizer st) throws IOException
    {
        if(st.ttype != StreamTokenizer.TT_NUMBER) 
            throw new RuntimeException("Badly formed int at "+st.toString());
        double numb = st.nval;
        st.nextToken();
        return (int)numb;
    }
    
    // Read the current token as a boolean and move on to next token
    static boolean parseBoolean(StreamTokenizer st) throws IOException
    {
        
        if(st.ttype != StreamTokenizer.TT_WORD) 
            throw new RuntimeException("Badly formed boolean at "+st.toString());
        boolean out = st.sval.equalsIgnoreCase("true");
        st.nextToken();
        return out;
    }
    
    
    static boolean foundClosingSquareBrace(StreamTokenizer st)
    {
        if(st.ttype == StreamTokenizer.TT_WORD)
        {
            if(st.sval.equalsIgnoreCase("]"))
                return true;
            else
                return false;
        }    
        else
            return false;
    }
    
    static boolean foundClosingCurlyBrace(StreamTokenizer st)
    {
        if(st.ttype == StreamTokenizer.TT_WORD)
        {
            if(st.sval.equalsIgnoreCase("}"))
                return true;
            else
                return false;
        }    
        else
            return false;
    }
    

    
    // currentLevel is a DIRECTORY containing grouping or shape nodes at the current
    // level of the heirarchy.
    // out is a writer open on the top level file for the current level. Any
    // shape nodes written out at the current level should be <include>'ed in this
    // file.
    public static void writeNode(BufferedWriter outTop, File topLevel, File currentLevel, VrmlNode node, int indent) throws IOException
    {
        
        
        if(node instanceof AbstractGroupingNode)
        {
            AbstractGroupingNode gNode;
            
            if(node instanceof VrmlGroupNode)          gNode = (VrmlGroupNode)node;
            else if(node instanceof VrmlTransformNode) gNode = (VrmlTransformNode)node;
            else
                throw new RuntimeException("Unrecognized grouping node type: "
                                            +node.getClass());
            
            // Sanity check: if grouping node contains no children, don't
            // bother to write anything out. I guess this could happen for
            // inefficient VRML exporters
            if(!gNode.children.isEmpty())
            {
            
                // Grouping nodes with a single child are regarded as special
                // cases, and we prune unnecessary levels of the heirarchy.
                if(gNode.children.size()==1)
                {
                    // Propagate user-specified names to child nodes that are
                    // grouping nodes.
                    if(gNode.children.get(0) instanceof AbstractGroupingNode)
                    {
                        if(!VrmlNode.nameIsAutoGenerated(gNode.name))
                            gNode.children.get(0).name = gNode.name;
                    }
                        
                    // Write node to file
                    int extra_indent = gNode.writeNodeHeader(outTop, indent);
                    writeNode(outTop, topLevel, currentLevel, gNode.children.get(0), indent+extra_indent);
                    gNode.writeNodeFooter(outTop, indent);
                    
                }
                // Multiple children: create a new directory to store them all,
                // and <include> them.
                else
                {
                    // Non-trivial grouping node: start new level in heirarchy
                
                    // Create new folder, move into it then read children of this
                    // grouping node.
                    File nextLevel = new File(currentLevel, node.name);
                    nextLevel.mkdir();

                    // Make top level PXN file to include all child nodes
                    File pxn = new File(currentLevel, node.name+".pxn");
                    // Include this file in the top level
                    PXN_Utils.writeInclude(outTop, topLevel, pxn, indent, indentChar, !VrmlNode.nameIsAutoGenerated(gNode.name));


                    BufferedWriter out = new BufferedWriter(new FileWriter(pxn));
                    PXN_Utils.writePXNHeader(out);

                    int extra_indent = gNode.writeNodeHeader(out, 0);

                    for(VrmlNode child : gNode.children)
                    {
                        writeNode(out, topLevel, nextLevel, child, extra_indent);
                    }
                    
                    gNode.writeNodeFooter(out, 0);
                    
                    PXN_Utils.writePXNFooter(out);
                }
            
            }
            
        }
        else if(node instanceof VrmlShapeNode)
        {
            
            VrmlShapeNode sNode = (VrmlShapeNode)node;
            
            // Write PXN file for this shape
            File pxn = new File(currentLevel, node.name+".pxn");
            BufferedWriter out = new BufferedWriter(new FileWriter(pxn));
            PXN_Utils.writePXNHeader(out);
            sNode.writePXN(out, indent);
            PXN_Utils.writePXNFooter(out);
            
            // Include this PXN in the parent level.
            PXN_Utils.writeInclude(outTop, topLevel, pxn, indent, indentChar, !VrmlNode.nameIsAutoGenerated(sNode.name));
            
        }
        else
        {
            throw new RuntimeException("writeNode on wrong type: "+node.getClass());
        }
        
    }
    
    
    
    
    
    
    
    
}
